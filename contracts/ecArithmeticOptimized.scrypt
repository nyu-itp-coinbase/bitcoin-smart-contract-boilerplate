struct Point {
    int x;
    int y;
}

struct Signature {
    int r;
    int s;
}

library EC {

    static const int S = 33;    // 32 bytes plus sign byte
    // upper bound for eGCD
    static const int UB = 368;
    static const Point G = { 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
                             0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 };

    static const int n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;
    static const bytes bn = b'414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff';  // LE

    static const int P = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;
    static const bytes bP = b'2ffcfffffeffffffffffffffffffffffffffffffffffffffffffffffffffffff';  // LE

    static function modReduce(int k, int modulus) : int {
        int res = k % modulus;
        return (res < 0) ? res + modulus : res;
    }

    static function modInverseEGCD(int x, int n) : int {
        // The following script already does modular reduction at the start so there's no
        // need to normalize x before function call.
        asm {
            OP_2DUP OP_MOD OP_DUP OP_0 OP_LESSTHAN OP_IF OP_DUP OP_2 OP_PICK OP_ADD OP_ELSE OP_DUP OP_ENDIF OP_NIP OP_2 OP_ROLL OP_DROP
            OP_DUP OP_TOALTSTACK OP_TOALTSTACK OP_TOALTSTACK
            OP_1 OP_0 OP_1
            loop(UB) {
                OP_FROMALTSTACK OP_FROMALTSTACK OP_2DUP OP_DUP OP_IF OP_TUCK OP_MOD OP_TOALTSTACK OP_TOALTSTACK OP_DIV OP_MUL OP_SUB OP_TUCK OP_ELSE OP_TOALTSTACK OP_TOALTSTACK OP_DROP OP_DROP OP_ENDIF
            }
            OP_FROMALTSTACK OP_FROMALTSTACK OP_DROP OP_DROP OP_DROP OP_FROMALTSTACK OP_SWAP OP_NIP
        }
    }
    
    static function negatePoint(Point p) : Point {
        Point res = {p.x, modReduce(p.y * -1, P)};
        return res;
    }

    static function doublePoint(Point p) : Point {
        int lambda = (3 * p.x * p.x) * modInverseEGCD(2 * p.y, P);

        int rx = modReduce(lambda * lambda - 2 * p.x, P);
        int ry = modReduce(lambda * (p.x - rx) - p.y, P);
        
        Point res = {rx, ry};
        return res;
    }

    static function addPoints(Point p, Point q) : Point {
        Point ret = {0, 0};

        if (p.x == 0 && p.y == 0) {
            // if P == inf -> P + Q = Q
            ret = q;
        } else if (q.x == 0 && q.y == 0) {
            // if Q == inf -> P + Q = P
            ret = p;
        } else {
            int lambda = 0;
            if (p.x == q.x && p.y == q.y) {
                lambda = (3 * p.x * p.x) * modInverseEGCD(2 * p.y, P);
            } else {
                lambda = (q.y - p.y) * modInverseEGCD(q.x - p.x, P);
            }

            int rx = modReduce(lambda * lambda - p.x - q.x, P);
            int ry = modReduce(lambda * (p.x - rx) - p.y, P);

            ret = {rx, ry};
        }

        return ret;
    }

    static function multByScalar(Point p, int m) : Point {
        // Double and add method.
        // Lowest bit to highest.
        Point n = p;
        Point q = {0, 0};

        bytes mb =   reverseBytes(num2bin(m, S), S);
        bytes mask = reverseBytes(num2bin(1, S), S);
        bytes zero = reverseBytes(num2bin(0, S), S);

        loop (256) : i {
            if ((mb & (mask << i)) != zero) {
                q = addPoints(q, n);
            }

            n = doublePoint(n);
        }

        return q;
    }

    static function verifySig(bytes m, Signature sig, Point pubKey) : bool {
        Sha256 hash = hash256(m);
        int hashInt = unpack(reverseBytes(hash, 32));

        require(sig.r >= 1 && sig.r < n && sig.s >= 1 && sig.s < n);

        int sInv = modInverseEGCD(sig.s, n);
        int u1 = modReduce(hashInt * sInv, n);
        int u2 = modReduce(sig.r * sInv, n);

        Point U1 = multByScalar(G, u1);
        Point U2 = multByScalar(pubKey, u2);
        Point X = addPoints(U1, U2);

        return sig.r == X.x;
    }

}
